 REPTSTART0
 CLASSDECLORFUNCDEF REPTSTART0
 CLASSDECL REPTSTART0
 S45 class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : id S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function id S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function id S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => TYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function id S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function id S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires S1 colon S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : S3 lpar FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( FPARAMS rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( id S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 rpar S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) S35 arrow RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => RETURNTYPE S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void S2E semi S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; S43 REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; CLASSDECL REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; S45 class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : id S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; CLASSDECL REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; S45 class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer ARRAYSIZE REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer lsqbr ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ ARRAYSIZEPRIME REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ intlit S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 S5X rsqbr REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; CLASSDECL REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; S45 class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; CLASSDECL REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; S45 class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class id S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car S1 S3 OPTCLASSDECL2 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa id S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa id S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle comma id S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , id S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport S1 REPTOPTCLASSDECL22 S44 lcurbr REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { VISIBILITY S41 MEMBERDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { MEMBERVARDECL REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute id S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm S1 colon TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : TYPE S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer S2 S3 REPTMEMBERVARDECL4 S6 S42 semi REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; REPTCLASSDECL4 rcurbr semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } semi S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; S46 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: id S1 FUNCMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires S1 FUNCMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => TYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return lpar EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return lpar EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( ARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self S3 S9 S10 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: id S1 FUNCMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires S1 FUNCMETHOD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( id S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires S3 S9 S10 ASSIGNOP EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires equal EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = ARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = TERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main S38 S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { LOCALVARDECL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : id S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car S3 REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; LOCALVARDECL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : id S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car S3 REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car ARRAYSIZE REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car lsqbr ARRAYSIZEPRIME REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ ARRAYSIZEPRIME REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ intlit S5X rsqbr REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 S5X rsqbr REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] S9 S28 ASSIGNOP EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] equal EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = ARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = TERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; LOCALVARDECL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer S3 REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires S3 lpar APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( EXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read S25 lpar VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read S25 lpar VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( id S1 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars S1 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars S3 INDICE VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars lsqbr ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] S9 S28 dot id S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . id S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec S3 INDICE VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec lsqbr ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ TERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ lpar ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( lpar ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 ADDOP S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 minus S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) ADDOP S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) plus S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + lpar ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) MULTOP S18 FACTOR S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) mult S18 FACTOR S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * S18 FACTOR S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * lpar ARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( ARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( TERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) S19 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) ADDOP S20 TERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) minus S20 TERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - S20 TERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] S9 S28 rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read S25 lpar VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read S25 lpar VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( VARIABLE rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( id S1 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars S1 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars S3 INDICE VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars lsqbr ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] S9 S28 dot id S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . id S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec S1 S8 VARPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec S3 INDICE VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec lsqbr ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ TERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] INDICE VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] lsqbr ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ ARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ TERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] VARINDICEPRIME rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] S9 S28 rpar S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) S26 semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( ARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires VARIABLEORFUNCPRIME1 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires S3 lpar APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( ARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic VARIABLEORFUNCPRIME1 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic S3 lpar APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( EXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + lpar ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 MULTOP S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 div S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / intlit S5 S19 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 S5 S19 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + lpar ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] S9 S28 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + lpar ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( ARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] S9 S28 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] S9 S28 dot id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] S9 S28 dot id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . id S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x S1 S8 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x S3 INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] S9 S28 ASSIGNOP EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] equal EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = ARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = TERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( ARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] S9 S28 dot id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . id S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x S1 S8 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x S3 INDICE VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x lsqbr ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ ARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] VARIABLEORFUNCPRIME2 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] S9 S28 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional S3 lpar APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop S3 lpar APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( APARAMS rpar S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) S22 S29 VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) semi REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic S38 S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( id S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x S1 colon TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : TYPE S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer S2 S3 REPTFPARAMS3 S6 S7 REPTFPARAMS4 S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => TYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return lpar EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return lpar EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( EXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( ARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x MULTOP S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x mult S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * S18 FACTOR S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * lpar ARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( ARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( TERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 ADDOP S20 TERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 plus S20 TERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + S20 TERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) S19 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) semi S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; S31 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional S38 S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if lpar MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if lpar MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( ARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( TERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 gt S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > TERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > FACTOR RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then STATEMENT S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write lpar EXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write lpar EXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( EXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( ARITHEXPR RELEXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) semi S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; S30 S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else STATEMENT S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write lpar EXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write lpar EXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( EXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( ARITHEXPR RELEXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) semi S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; S30 S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if lpar MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if lpar MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( MYRELEXPRCONSTRUCT rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( TERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( lpar ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic VARIABLEORFUNCPRIME1 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic S3 lpar APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( APARAMS rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( EXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) S22 S29 VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) geq S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= S23 ARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= TERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= FACTOR RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= lpar ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( ARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( TERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 S5 RIGHTRECTERM RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 ADDOP S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 minus S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - S20 TERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR rpar RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then S3 STATBLOCK S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then lcurbr REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { STATEMENT REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write lpar EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write lpar EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( ARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) semi S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; S30 REPTSTATBLOCK1 rcurbr S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } S32 else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else S3 STATBLOCK S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else lcurbr REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { STATEMENT REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write lpar EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write lpar EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( EXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( ARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) semi S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; S30 REPTSTATBLOCK1 rcurbr S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } S32 semi S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; S33 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } CLASSDECLORFUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } FUNCDEF REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } FUNCHEAD FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function id S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop S40 FUNCSCOPEDFREE FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop S38 S3 lpar FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( FPARAMS S35 rpar arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) arrow RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => RETURNTYPE S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void S2E FUNCBODY REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void lcurbr S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { S3 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { LOCALVARDECL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar id S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x S1 colon TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : TYPE S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer S2 LOCALVARDECLPRIME S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer S3 REPTLOCALVARDECL4 S6 semi S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; S7 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while lpar MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while lpar MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( ARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( TERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x leq S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= TERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= FACTOR RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) STATEMENT S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) VARIABLEASSIGNORFUNCCALL S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) id S1 VARIABLEASSIGNORFUNCCALLPRIME S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x S1 VARIABLEASSIGNORFUNCCALLPRIME S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x S3 S9 S10 ASSIGNOP EXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x equal EXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = EXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = ARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = TERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; S27 S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( ARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x S1 VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x S3 S9 S10 ASSIGNOP EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x equal EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = EXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = ARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = TERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 S5 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; S27 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while lpar MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while lpar MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( MYRELEXPRCONSTRUCT rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( ARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( TERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELOP S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x leq S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= S23 ARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= TERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= FACTOR RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= intlit S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 S5 RIGHTRECTERM RIGHTRECARITHEXPR S24 rpar S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) S3 STATBLOCK S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) lcurbr REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { STATEMENT REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { VARIABLEASSIGNORFUNCCALL REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { id S1 VARIABLEASSIGNORFUNCCALLPRIME REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x S1 VARIABLEASSIGNORFUNCCALLPRIME REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x S3 S9 S10 ASSIGNOP EXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x equal EXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = EXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = ARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = TERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x ADDOP S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x plus S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + S20 TERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + FACTOR RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + intlit S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 S5 RIGHTRECTERM S21 RIGHTRECARITHEXPR RELEXPR semi S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; S27 REPTSTATBLOCK1 rcurbr S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } S32 semi S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; S34 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; LOCALVARDECLORSTMT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; STATEMENT REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write lpar EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( EXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( ARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( id S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( x S1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( x S3 S9 S10 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( x ) semi S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( x ) ; S30 REPTFUNCBODY1 S32 rcurbr S36 REPTSTART0
class vehicle { private attribute tires : integer ; attribute doors : integer ; public attribute spec : integer [ 5 ] ; public attribute nesting : nestedX [ 1 ] ; public attribute multiSpec : integer [ 1 ] [ 1 ] ; public function getTires : ( ) => integer ; function setTires : ( x : integer ) => void ; } ; class nestedX { attribute x : nestedY [ 5 ] [ 5 ] ; } ; class nestedY { attribute x : integer [ 5 ] ; } ; class transport { private attribute fuel : integer ; } ; class car isa vehicle , transport { attribute rpm : integer ; } ; function vehicle :: getTires ( ) => integer { return ( self . tires + 4 ) ; } function vehicle :: setTires ( x : integer ) => void { tires = x ; } function main ( ) => void { localvar myCar : car ; localvar myCars : car [ 2 ] ; myCars [ 1 ] = myCar ; localvar x : integer ; myCars [ 1 ] . setTires ( 10 ) ; read ( myCars [ 1 ] . spec [ ( ( 200 - 198 ) + ( 1 ) * ( 2 ) ) - 3 ] ) ; read ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ; write ( myCars [ 1 ] . getTires ( ) ) ; write ( complexArithmetic ( 10 ) + ( 200 / 2 ) + ( myCars [ 1 ] . spec [ 1 ] ) + ( myCars [ 1 ] . multiSpec [ 0 ] [ 1 ] ) ) ; myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] = 101 ; write ( myCars [ 1 ] . nesting [ 0 ] . x [ 1 ] [ 2 ] . x [ 0 ] ) ; conditional ( ) ; loop ( ) ; } function complexArithmetic ( x : integer ) => integer { return ( x * ( 4 + 6 ) ) ; } function conditional ( ) => void { if ( 1 > 1 ) then write ( 100 ) ; else write ( 200 ) ; ; if ( ( complexArithmetic ( 10 ) ) >= ( 200 - 100 ) ) then { write ( 100 ) ; } else { write ( 200 ) ; } ; } function loop ( ) => void { localvar x : integer ; while ( x <= 20 ) x = x + 1 ; ; write ( x ) ; x = 0 ; while ( x <= 20 ) { x = x + 1 ; } ; write ( x ) ; } S36 REPTSTART0
