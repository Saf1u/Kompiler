 REPTSTART0
 CLASSDECLORFUNCDEF REPTSTART0
 CLASSDECL REPTSTART0
 class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => TYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; CLASSDECL REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa id REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa id REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor colon lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor colon lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float FPARAMSTAIL REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => TYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; CLASSDECL REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class id OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC OPTCLASSDECL2 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa id REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa id REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL REPTOPTCLASSDECL22 lcurbr REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private MEMBERVARDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute id colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c colon TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : TYPE REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float REPTMEMBERVARDECL4 semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor colon lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor colon lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : lpar FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( FPARAMS rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float FPARAMSTAIL REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float FPARAMSTAIL REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; VISIBILITY MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public MEMBERDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public MEMBERFUNCDECL REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function id colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate colon lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : lpar FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( FPARAMS rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) arrow RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => RETURNTYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => TYPE semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float semi REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; REPTCLASSDECL4 rcurbr semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } semi REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; FUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; FUNCHEAD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: id FUNCMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate FUNCMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = TYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float lcurbr REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { LOCALVARDECL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float REPTLOCALVARDECL4 semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x ADDOP TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x plus TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result MULTOP FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result mult FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x ADDOP TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x plus TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( ARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } FUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } FUNCHEAD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor FUNCCONSTRUCTOR FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor FUNCCONSTRUCTOR FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor lpar FPARAMS rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( FPARAMS rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float FPARAMSTAIL REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float FPARAMSTAIL REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) lcurbr REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } FUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } FUNCHEAD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor FUNCCONSTRUCTOR FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor FUNCCONSTRUCTOR FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor lpar FPARAMS rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( FPARAMS rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float REPTFPARAMS3 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float FPARAMSTAIL REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float comma id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , id colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B colon TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : TYPE REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float REPTFPARAMSTAIL4 REPTFPARAMS4 rpar FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) lcurbr REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } FUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } FUNCHEAD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR sr FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: FUNCCONSTRUCTORORMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: id FUNCMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate FUNCMETHOD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( id colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x colon TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : TYPE REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float REPTFPARAMS3 REPTFPARAMS4 rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => TYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float lcurbr REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { LOCALVARDECL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float REPTLOCALVARDECL4 semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = floatlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a ADDOP TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a plus TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return lpar EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( EXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( ARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } CLASSDECLORFUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } FUNCDEF REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } FUNCHEAD FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function id FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main FUNCSCOPEDFREE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main lpar FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( FPARAMS rpar arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) arrow RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => RETURNTYPE FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void FUNCBODY REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void lcurbr REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { LOCALVARDECL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: id LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC lpar APARAMS rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( APARAMS rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( EXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( SIGN FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( minus FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - floatlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 APARAMSTAIL REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 comma EXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , EXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , ARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , floatlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 APARAMSTAIL REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 comma EXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , EXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , ARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , floatlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; LOCALVARDECL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar id colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter colon TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : TYPE LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer LOCALVARDECLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer REPTLOCALVARDECL4 semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id dot id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id dot id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id dot id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = intlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ intlit RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = intlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = intlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id lpar APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id lpar APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = intlit RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; VARIABLEASSIGNORFUNCCALL REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ intlit RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] INDICE VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] lsqbr ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ ARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ TERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ FACTOR RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ intlit RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 RIGHTRECTERM RIGHTRECARITHEXPR rsqbr VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] VARIABLEASSIGNORFUNCCALLPRIME2 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id VARIABLEASSIGNORFUNCCALLPRIME1 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id lpar APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( APARAMS rpar VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) VARIABLEASSIGNORFUNCCALLPRIME3 REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) dot id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id VARIABLEASSIGNORFUNCCALLPRIME REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id ASSIGNOP EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id equal EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = EXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = ARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = TERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; LOCALVARDECLORSTMT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; STATEMENT REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while lpar MYRELEXPRCONSTRUCT rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while lpar MYRELEXPRCONSTRUCT rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( MYRELEXPRCONSTRUCT rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( ARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( TERM RIGHTRECARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELOP ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter leq ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= ARITHEXPR rpar STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > STATBLOCK semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > lcurbr REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( ARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( ARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 dot id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate VARIABLEORFUNCPRIME1 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate lpar APARAMS rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( APARAMS rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( EXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; STATEMENT REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; write lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; lpar EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( EXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( ARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( TERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 dot id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate VARIABLEORFUNCPRIME1 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate lpar APARAMS rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( APARAMS rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( EXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( ARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( TERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( FACTOR RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( VARIABLEORFUNC RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( id VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter VARIABLEORFUNCPRIME RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR REPTAPARAMS1 rpar VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) VARIABLEORFUNCPRIME3 RIGHTRECTERM RIGHTRECARITHEXPR RELEXPR rpar semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) ) semi REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) ) ; REPTSTATBLOCK1 rcurbr semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) ) ; } semi REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) ) ; } ; REPTFUNCBODY1 rcurbr REPTSTART0
class POLYNOMIAL { public function evaluate : ( x : float ) => float ; } ; class LINEAR isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; public constructor : ( A : float , B : float ) ; public function evaluate : ( x : float ) => float ; } ; class QUADRATIC isa POLYNOMIAL { private attribute a : float ; private attribute b : float ; private attribute c : float ; public constructor : ( A : float , B : float , C : float ) ; public function evaluate : ( x : float ) => float ; } ; function POLYNOMIAL :: evaluate ( x : float ) = float { localvar result : float ; result = a ; result = result * x + b ; result = result * x + c ; return ( result ) ; } function QUADRATIC :: constructor ( A : float , B : float , C : float ) { self . a == b = B ; self . c = C ; } function LINEAR :: constructor ( A : float , B : float ) { self . a == b = B ; } function LINEAR :: evaluate ( x : float ) => float { localvar result : float ; result = 0.0 ; result = a = b ; aha = x ; return ( result ) ; } function main ( ) => void { localvar f1 :: QUADRATIC ( - 2.0 , 1.0 , 0.0 ) ; localvar counter : integer ; counter = id . id . id . id ; id = 3 ; id . id [ 3 ] = 4 ; id . id . id . id . id = 40 ; id . id ( ) . id ( ) . id = 22 ; id . id . id . id . id . id [ 3 ] [ 3 ] . id ( ) . id = id ; while ( counter <= > { write ( counter ) ; write ( f1 . evaluate ( counter ) ) ; ; ( f2 . evaluate ( counter ) ) ; } ; } REPTSTART0
